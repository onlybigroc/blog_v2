---
title: "软件设计哲学"
date: 2024-04-29T16:00:00.000Z
slug: 
categories: []
tags: []
summary: "Philosophy 模块原则：使用简洁的接口拼合简单的部件 “计算机编程的本质就是控制复杂度”。 要编制复杂软件而又不至于一败涂地的唯一的方法就是降低其整体复杂度——用清晰的接口把若干个简单的模块组合成一个复杂的软件。如此一来，多数问题就只会局限于某个局部，那么还有希望对局部进行改进而不至于牵动全身。 清晰原则：清晰胜于机巧 程序是给人看的，而不是机器。 这个原则不仅仅是指可读性，同时也指在选择..."
originUrl: "https://www.cnblogs.com/bigroc/p/18168081"
---

# Philosophy

## 模块原则：使用简洁的接口拼合简单的部件

> “计算机编程的本质就是控制复杂度”。

要编制复杂软件而又不至于一败涂地的唯一的方法就是降低其整体复杂度——用清晰的接口把若干个简单的模块组合成一个复杂的软件。如此一来，多数问题就只会局限于某个局部，那么还有希望对局部进行改进而不至于牵动全身。

## 清晰原则：清晰胜于机巧

> 程序是给人看的，而不是机器。

这个原则不仅仅是指可读性，同时也指在选择算法和实现时就应该考虑到未来的可扩展性。不要为了提升一丁点的程序的性能就增加技术的复杂性和晦涩性——因为复杂的代码更容易滋生bug，也因为它会使日后的阅读和维护工作更加艰难。

优雅而清晰的代码不仅不容易崩溃——而且更利于后来的修改者立刻理解。

## 组合原则：设计时考虑拼接组合

要想让程序具有组合性，就必须是程序彼此独立。在文本流这一端的程序应该尽可能不要考虑文本流另一端的程序。将一端的程序替换为一个截然不同的程序，而完全不惊扰另一端的程序应该很容易做到。

对于协议的设计，尽量采用简单的文本数据格式。

## 分离原则：策略同机制分离，接口同引擎分离

要想让程序具有组合性，就必须是程序彼此独立。在文本流这一端的程序应该尽可能不要考虑文本流另一端的程序。将一端的程序替换为一个截然不同的程序，而完全不惊扰另一端的程序应该很容易做到。

对于协议的设计，尽量采用简单的文本数据格式。

## 简洁原则：设计要简洁，复杂度能低则低

> 简洁总是难以保持的

## 吝啬原则：除非确无他法，不要编写庞大的程序

避免编写庞大程序的方法的分割程序。一个程序只做好一件事情。

透明性原则：设计要可见，以便审查和调试

一眼就能看出软件在做什么以及怎么做的

## 健壮原则：健壮源于透明与简洁

健壮性是指软件不仅在正常的情况下运行良好，而且在超出设计者设想的意外条件下也能够运行良好。模块性（代码简朴，接口简洁）是组织程序以达到更简洁目的的一个方法。

## 表示原则：把知识叠入数据以求逻辑质朴而健壮

用简单的逻辑和负责

## 补救原则：出现异常时，马上退出并给出足够错误信息

## 生成原则：避免手工hack，尽量编写程序去生成程序

也就是教会机器去做更多低层次的编程工作。

一个方向就是DSL。

## 优化原则：雕琢前先得有原型，跑前先学会走

过早优化是万恶之源，他会损害设计。

先给你的设计做个未优化的，运行缓慢的，很耗内存但是正确的实现，然后向进行系统调整，寻找那些可以牺牲最小的局部的简洁性而获得较大的性能提升的地方。

## 多样原则：决不相信所谓的“不二法门”的断言

即使最出色的软件也常常会受限于设计者的想象力。一个好的应用广泛采用多种语言、开放的可扩展机制和用户定制机制。

## 扩展原则：设计着眼未来，未来总比预想快

设计协议或者文本格式时，应使其具有充分的自描述性以便扩展。

设计代码时，要有很好的组织，让将来的开发者增加新功能时无需拆毁或重建整个架构。

## 单一职责：不做两件事情

## 开闭原则

## 接口隔离原则

1、客户端不应该依赖它不需要的接口。  
2、类间的依赖关系应该建立在最小的接口上。

## 依赖倒置原则

1、上层模块不应该依赖底层模块，它们都应该依赖于抽象。  
2、抽象不应该依赖于细节，细节应该依赖于抽象。

## 通俗原则：最小立异

最易用的程序就是用户学习新东西最少的程序。  
另一个方面是避免表象相同而实际却略有不同，这会及其危险。最好让不同事物有明显区别，而不要看起来几乎一模一样。  
命名、接口设计、参数设计要遵循一个习惯和常识，不要尝试违背常识和习惯。

## 参考：

> [Unix哲学之编程原则](https://www.51cto.com/article/780076.html)