---
title: "你好，Cargo"
date: 2024-03-12T16:00:00.000Z
slug: cargo
categories: []
tags: []
summary: "你好，Cargo Cargo 是 Rust 的构建系统和包管理器。大多数 Rustaceans 使用这个工具来管理他们的 Rust 项目，因为 Cargo 会为您处理很多任务，例如构建代码、下载代码所依赖的库以及构建这些库。（我们将您的代码需要的库称为 “依赖项”。） 最简单的 Rust 程序，就像我们迄今为止编写的程序一样，没有任何依赖项。如果我们建造了“你好，世界！” 使用 Cargo 进行项..."
originUrl: "https://www.cnblogs.com/bigroc/p/18070294"
---

# 你好，Cargo

Cargo 是 Rust 的构建系统和包管理器。大多数 Rustaceans 使用这个工具来管理他们的 Rust 项目，因为 Cargo 会为您处理很多任务，例如构建代码、下载代码所依赖的库以及构建这些库。（我们将您的代码需要的库称为 “依赖项”。）

最简单的 Rust 程序，就像我们迄今为止编写的程序一样，没有任何依赖项。如果我们建造了“你好，世界！” 使用 Cargo 进行项目时，它只会使用 Cargo 中处理构建代码的部分。当你编写更复杂的 Rust 程序时，你将添加依赖项，如果你使用 Cargo 启动一个项目，添加依赖项会更容易。

由于绝大多数 Rust 项目都使用 Cargo，因此本书的其余部分假设您也使用 Cargo。[如果您使用“安装”](https://www.cnblogs.com/bigroc/p/18063166 "如果您使用“安装”")部分中讨论的官方安装程序，Cargo 会随 Rust 一起安装 。如果您通过其他方式安装了 Rust，请在终端中输入以下内容来检查 Cargo 是否已安装：

```shell
cargo --version
```

如果您看到版本号，则说明您已拥有它！如果您看到错误，例如command not found，请查看您的安装方法的文档，以确定如何单独安装 Cargo。

## 使用 Cargo 创建项目

让我们使用 Cargo 创建一个新项目，看看它与我们原来的“Hello, world!”有何不同。项目。导航回您的项目目录（或您决定存储代码的任何位置）。然后，在任何操作系统上运行以下命令：

```shell
cargo new hello_cargo
cd hello_cargo
```

第一个命令创建一个名为hello\_cargo的新目录和项目。我们将项目命名为hello\_cargo，Cargo 在同名目录中创建其文件。

进入hello\_cargo目录并列出文件。你会看到 Cargo 为我们生成了两个文件和一个目录：一个`Cargo.toml`文件和一个 src目录，里面有一个`main.rs`文件。

它还初始化了一个新的 Git 存储库以及一个.gitignore文件。`cargo new`如果您在现有的 Git 存储库中运行，则不会生成 Git 文件；您可以使用 覆盖此行为`cargo new --vcs=git`。

> **注**：Git 是一个常见的版本控制系统。您可以`cargo new`使用该标志更改为使用不同的版本控制系统或不使用版本控制系统`--vcs`。运行`cargo new --help`以查看可用选项。

在您选择的文本编辑器中打开`Cargo.toml` 。

```
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

```

该文件采用[TOML](https://toml.io/cn/v1.0.0 "TOML")（Tom's Obvious，Minimal Language）格式，这是 Cargo 的配置格式。

第一行`[package]`是节标题，指示以下语句正在配置包。当我们向该文件添加更多信息时，我们将添加其他部分。

接下来的三行设置 Cargo 编译程序所需的配置信息：名称、版本和要使用的 Rust 版本。edition我们将在[附录 E](https://doc.rust-lang.org/book/appendix-05-editions.html "附录 E")中讨论密钥。

最后一行`[dependencies]`是一个部分的开始，您可以在此列出项目的任何依赖项。在 Rust 中，代码包被称为 crates。该项目不需要任何其他 crate。

现在打开src/main.rs看看：

文件名：src/main.rs

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo 生成了“Hello, world!” 为您准备的程序，就像我们编写的程序一样！到目前为止，我们的项目和 Cargo 生成的项目的区别在于 Cargo 将代码放在src目录中，并且我们在顶层目录中有一个Cargo.toml配置文件。

Cargo 希望您的源文件位于src目录中。顶级项目目录仅用于 README 文件、许可证信息、配置文件以及与代码无关的任何其他内容。使用 Cargo 可以帮助您组织项目。一切都有一个地方，一切都在它的位置上。

如果您启动了一个不使用 Cargo 的项目，就像我们对“Hello, world!”所做的那样 项目，您可以将其转换为使用 Cargo 的项目。将项目代码移至src目录并创建适当的Cargo.toml 文件。

## 构建和运行 Cargo 项目

现在，让我们来看看使用Cargo构建和运行“Hello, world!”程序时有什么不同之处！从您的hello\_cargo目录中，通过输入以下命令构建您的项目：

```shell
cargo build
```

此命令在target/debug/hello\_cargo（或 Windows 上的target\\debug\\hello\_cargo.exe ）而不是在当前目录中创建可执行文件。由于默认构建是调试构建，因此 Cargo 将二进制文件放在名为debug的目录中。您可以使用以下命令运行可执行文件：

```
./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!

```

如果一切顺利，Hello, world!应该打印到终端。第一次运行`cargo build`还会导致 Cargo 在顶层创建一个新文件：`Cargo.lock`。该文件跟踪项目中依赖项的确切版本。该项目没有依赖项，因此文件有点稀疏。您无需手动更改此文件；Cargo 为您管理其内容。

我们刚刚使用 构建了一个项目并`cargo build`使用 运行它 ./target/debug/hello\_cargo，但我们也可以使用`cargo run`来编译代码，然后在一个命令中运行生成的可执行文件：

```
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

使用`cargo run`比运行`cargo build`然后使用二进制文件的完整路径要方便得多，因此大多数开发人员都使用`cargo run`。

请注意，这次我们没有看到表明 Cargo 正在编译的输出 hello\_cargo。Cargo 发现文件没有改变，所以它没有重建，只是运行二进制文件。如果您修改了源代码，Cargo 将在运行之前重新构建项目，并且您将看到以下输出：

```
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo 还提供了一个名为 的命令`cargo check`。此命令快速检查您的代码以确保它可以编译但不会生成可执行文件：

```
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs

```

为什么你不想要一个可执行文件？通常，`cargo check`比`cargo build`要快得多，因为它跳过了生成可执行文件的步骤。如果您在编写代码时不断检查您的工作，那么使用`cargo check`将加快让您知道项目是否仍在编译的过程！因此，许多 Rustaceans `cargo check`在编写程序时定期运行以确保其可以编译。然后，`cargo build`当它们准备好使用可执行文件时，它们就会运行。

让我们回顾一下到目前为止我们所学到的有关 Cargo 的知识：

*   我们可以使用创建一个项目`cargo new`。
*   我们可以使用 来构建一个项目`cargo build`。
*   我们可以使用 一步构建并运行一个项目`cargo run`。
*   我们可以构建一个项目，而无需生成二进制文件来使用 `cargo check`.
*   Cargo 不将构建结果保存在与代码相同的目录中，而是将其保存在 target/debug 目录中。  
    使用 Cargo 的另一个优点是，无论您使用哪种操作系统，命令都是相同的。因此，目前我们将不再提供针对 Linux 和 macOS 与 Windows 的具体说明。

## 构建发布

当你的项目最终准备好发布时，你可以使用`cargo build --release`来编译它，并进行优化。这个命令将在`target/release`中创建一个可执行文件，而不是在`target/debug`中。这些优化会使你的 Rust 代码运行得更快，但开启它们会延长你的程序编译的时间。这就是为什么有两个不同的配置文件：一个用于开发，当你想要快速且频繁地重建时，另一个用于构建最终的程序，你将把它交给用户，并且它不会被反复重建，并且会尽可能快地运行。如果你正在对你的代码运行时间进行基准测试，请确保使用`cargo build --release`并在`target/release`中使用可执行文件进行基准测试。

# 概括

您的 Rust 之旅已经有了一个良好的开端！在本章中，您学习了如何：

*   使用以下命令安装 Rust 的最新稳定版本rustup
*   更新到较新的 Rust 版本
*   打开本地安装的文档
*   编写并运行“Hello, world!” 程序rustc直接使用
*   使用 Cargo 约定创建并运行一个新项目

现在是构建一个更充实的程序以习惯阅读和编写 Rust 代码的好时机。

## 参考来源

[doc.rust-lang.org/book](https://doc.rust-lang.org/book/ch01-03-hello-cargo.html)